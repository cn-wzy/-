## HTML 语义化

    根据内容的结构化（内容语义化）选择合适的标签（代码语义化）便于开发者阅读和写出更加优雅的代码同时让浏览器更加好地解析，H5添加了Header、Footer、nav、article、h1-h6等语义化标签

    目的：让开发者直观的认识标签和属性

## 标签 title 和 alt 属性的区别是什么

    相同点都会出现一个小浮层，显示图片相关的内容

    区别：
    alt属性：倘若图片加载不成功未能显示出来，就会在图片未显示的地方出现一段文字
    搜索引擎可以通过这个属性的文字获得图片

    title：
    title可以用在任何元素上，当用户把鼠标移动元素上，就会title内容起到对图片进行说明的作用，类似图片的备注

    当既设置了title又设置了alt，鼠标悬停的时候只展示title属性

## iframe 优缺点

    优点：
    iframe能够原封不动的把嵌入的网页展现出来
    多个网页引用iframe内容，只需要修改iframe，所有网页内容都会更改
    遇到加载缓慢的第三方图标，可以用iframe解决

    缺点：
    会产生很多页面不方便管理
    会增加服务器http请求，增加负担
    现在基本淘汰

## 介绍 CSS 盒子模型

    两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（context-box）
    分为内容content、padding内边距、margin外边距、边框border组成
    W3C模型：width和height是不包含padding和border的
    IE模型：width和height是content+padding+border

## 垂直居中的几种方式

    父元素的height和line-height值相等

    vertical-align：middle以及line-height进行垂直居中

    .content{
        display: flex;
        align-items: center;
        justify-content: center;
    }

    绝对定位配合top:50%和负的margin-top（元素高度一半）进行垂直居中

    绝对定位，配合top:0;bottom:0;和margin:auto进行垂直居中

## rgba 和 opacity 的透明效果的不同

    opacity作用于元素，元素内的所有内容的透明度，而rgba只作于颜色或其背景颜色
    总的来说就是opacity子元素会继承二rgba不会

## position relative 和 absolute 分别是相对于谁进行定位的

    absolute：生成绝对定位元素，相对于最近一级不是static的父元素进行定位
    relative：生成相对定位元素，相对于在普通流的位置进行偏移

## H5 C3 新特性

    H5：
    （1）语义标签：<header><dialog>等
    （2）增强型表单：多个新的表单input输入类型，提供更好的输入控制和验证，新增表单元素<datalist><keygen>等 ，新增属性placehoder，required等
    （3）视频和音频：提供了播放音频文件的标准<audio></audio>,视频<video>
    （4）Canvas绘图（5）SVG绘图（可伸缩的矢量图形）：SVG和Canvas区别：SVG使用一种使用XML描述2d图像的语言，Canvas通过js来描绘，SVG每个被绘制的图形被视为对象，如果属性变换就会自动重现图形，Canvas是逐像素渲染，一旦绘制完成就不会得到浏览器的关注，位置发生变换整个场景都需要重新绘制
    （6）地理定位（Geolocation）
    （7）拖放API：
    （8）Web worker：在HTML页面执行脚本，页面状态是不可以响应的，他是运行在后台的js，独立于其他脚本，不影响页面性能
    （9）Web storage：在本地存储用户浏览数据
    （10）WebSocket：提供一种在TCP链接上进行全双工的通讯协议，浏览器和服务器做一个握手的动作，两者之间就可以直接数据传输

    C3：
    新增各种CSS选择器	（:not(.input)：所有class不是“input”的节点）
    圆角 （border-radius:8px）
    多列布局 （multi-column layout）
    阴影和反射 （Shadow\Reflect）
    文字特效 （text-shadow）
    文字渲染 （Text-decoration）
    线性渐变 （gradient）
    旋转 （transform）
    缩放，定位，倾斜，动画，多背景

## BFC 是什么

    块级格式上下文
    一个元素形成BFC后，内部元素不会影响到外部，外部元素也不会影响到内部。
    根元素是一个BFC区域，浮动和绝对定位也会形成BFC，display属性值为inline-box和flex也会创建BFC，元素的overflow不会visible都会创建BFC

## JS 的数据类型

    基本数据类型：number、string、Boolean、null、undefined、symbol、bigint
    引用数据类型：object

## 判断一个值是什么类型的方法

    typeof、instanceof、Object.prototype.toString()方法

## null 和 undefined 的区别

    undefined表示尚未初始化的变量的值
    -这个变量从根本上就没有定义
    -隐藏式空值
    -转为数值是NaN
    null表示该变量有意缺少对象指向
    -这个值定义了但未指向任何内存中的对象
    -声明式空置
    -转为数值是0

## 判断变量是否是数组

    instanceof、对象的constructor属性、Object.prototype.toString、Array对象的isArray方法

## 箭头函数的特点

    省略function换成=>，一个参数的时候省略（），一个return的时候省略return
    箭头函数的this是静态的，始终指向声明函数的作用域
    箭头函数不能使用arguments变量

## new 操作符具体干了什么。

    创建一个空对象，将 空对象的原型指向构造函数的原型，将空对象的作为构造函数的上下文（改变this指向为空对象），对构造函数有返回值的处理判断

## document.write 和 innerHTML 的区别

    document.write是直接将内容写入页面的内容流会导致页面全部重绘， 而innerHTML将内容写入某个DOM节点，不会导致页面全部重绘。

## 闭包

    「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。
    闭包就是能够读取其他函数内部变量的函数
    闭包常常用来间接访问一个变量
    function foo() {
        var local = 1;
        function bar() {
            local++;
            return local
        }
        return bar
    }
    var func = foo()
    func()

## js 的垃圾回收机制

    js的内存管理的概念是可达性
    可达性指的是以某种方式可访问或可用的值，他们被保证存储在内存中
    如果引用或引用链从跟访问到其他值，你们这个值被称作可访问的
    js引擎有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象
    基本的垃圾回收算法称为“标记-清除”，定期执行“垃圾回收步骤”
    垃圾回收器获取根并标记它们->然后访问并标记所有来自他们的引用->然后访问标记的对象并标记它们的引用->以此类推，直到所有可访问的全部被标记->除标记对象外所有对象都被删除

    优化：
    分代回收：对象分为“新对象”和“旧对象”。许多新对象完成他们的工作之后就无用了，很快就会被清楚，那些活的够久的对象，会“变老”，“老对象很少接受检查”。
    增量回收：引擎试图将垃圾回收分解为多个部分。各个部分分别执行，需要额外的标记来跟踪变化，这样有很多微小的延迟，但没有很大的延迟
    空闲时间收集：只在CPU空闲时间执行

    这里是更深层次的解释：http://newhtml.net/v8-garbage-collection/

## MVVM 和 MVC

    MVC：所有通信都是单项的。   视图（View）：用户界面（传送指令到Controller）  控制器（Controller）：业务逻辑（完成业务逻辑之后Model改变状态）     模型（Model）：数据保存（将新的数据发送到View，用户得到反馈）
    MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新


    MVVM：  model：服务器的业务逻辑操作     view：用户界面      viewmodel：核心枢纽
    viewmodel负责把Model的数据同步到View，把View修改同步到Model
    双向通信，视图和模型不发生联系，通过VM传递

    双向绑定是什么原理？
    Object.defineProperty。这个api能够监听到这个data的变化，在getter和setter里，当改变时调用setter。通知依赖Dep更新，依赖会有一个Watcher实例（谁订阅了这个Dep就为谁创建一个Watcher实例），数据发生变化通知Watcher实例，由其去通知真正的视图

## v-if 和 v-show 的区别

    手段：
    v-if是动态的向DOM树内添加或者删除DOM元素
    v-show是通过设置DOM元素的display样式属性控制显隐
    编译过程：
    v-if切换有一个局部编译、卸载的过程，切换过程中合适的重建内部的事件监听和子组件
    v-show只是简单的css切换
    编译条件：
    v-if是惰性的，如果初始条件是假就什么都不做，只有第一次为真之后才开始局部编译
    v-show是任何条件都被编译，然后缓存而且DOM元素保留
    性能：
    v-if有更高的切换消耗
    v-show有更高的初始渲染
    使用场景：
    v-if在运营条件不大改变的时候使用
    v-show适合频繁切换

## SPA 的理解

    单页面Web应用：是一种特殊的Web应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的
    优点：有良好的交互体验、前后端分离、减轻服务器压力、共用一段后端代码
    缺点：SEO难度高（搜索引擎爬虫）、前进后退管理、初次加载耗时多

## Vue 的单向数据流

    数据只能通过父组件传递给子组件，只能单向绑定；子组件内部不能直接修改从父级传递过来的数据
    原因：父组件值更新的时候，子组件可能也在更新，可能会发生错误

## computed 和 watch

    computed：计算属性，依赖其他的属性值，并且有缓存
    watch：观察，类似某些数据的监听回调
    当我们需要进行数值计算并且依赖其他数据应该使用computed，每次获取值的时候避免重新计算，减小开销
    当执行异步或者开销较大的操作时使用watch

## 直接给一个数组项赋值，Vue 能检测到变化吗

    js的限制，Vue不能检测到数组的变动，所以Vue有Vue.set和Vue.$set方法

## Vue 的父子组件的生命周期和钩子函数的执行顺序

    第一部分：首次加载渲染
    父beforeCreate-父created-父beforeMount-子beforeCreate-子created-子beforeMount-子mounted-父mounted

    第二部分：子组件更新
    父beforeUpdate-子beforeUpdate-子updated-父updated

    第三部分：父组件更新
    不会影响子组件

    第四部分：销毁过程
    父beforeDestory-子beforeDestory-子destroyed-父destroyed

## 父组件可以监听到子组件的生命周期吗

    $emit
    // Parent.vue
    <Child @mounted="doSomething"/>
    // Child.vue
    mounted() {
        this.$emit("mounted");
    }

    hook钩子函数
    //  Parent.vue
    <Child @hook:mounted="doSomething" ></Child>
    doSomething() {
        console.log('父组件监听到 mounted 钩子函数 ...');
    },
    // Child.vue
    mounted(){
        console.log('子组件触发 mounted 钩子函数 ...');
    },
